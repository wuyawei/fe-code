/* 
作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。 
*/
/* 
赋值操作符会导致 LHS 查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。
*/
/* 
左查询和右查询都是从当前作用域开始查找，没找到则向上继续查找，没找到最终会找到全局作用域，此时找没找到都会停止查找
*/
/* 
不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出 ReferenceError 异常（严格模式下）。
*/
function foo(a) {
    var b = a;
    return a + b;
}
var c = foo( 2 );
// LHS 3次  c=  a=  b=
// RHS 4次 foo  =a  a  b


/* 词法作用域 */
/* 
词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。
*/
/* 
避免使用eval(..) 和 with，都可以动态的修改已有的词法作用域。
并且他们都是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。
*/



/* 
作用域和块作用域
IIFE
try/catch、let、const
*/

/* 
变量、函数声明提升，函数声明先于变量
foo(); // 1
function foo() {     console.log( 1 ); } 
var foo = function() {     console.log( 2 ); };

只是变量提升优先，赋值是可以成功的
function foo() {     console.log( 1 ); } 
var foo = function() {     console.log( 2 ); };
foo(); // 2
*/